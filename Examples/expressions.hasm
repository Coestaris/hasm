;  Пример использования выражений в HASM
; - бинарные выражения (R1, R2, R3, R4, R5, R8, R9)
; - унарные выражения (R4, R8, R9)
; - функции (R6, R7, R9)
; - условные операторы (R5, R9)

init:   ldi R1, 1 + 1                                           ; Установить R1 как 2 
        ldi R2, 2 * 4 + 1                                       ; Установить R2 как 9
        ldi R3, 0x02 << 2                                       ; Установить R3 как 8
        ldi R4, !(0 && (1 || 0 || 0 || 1))                      ; Установить R4 как 0
        ldi R5, 4 % 2 == 0 ? 2 + 4 : 3 - 1                      ; Установить R5 как 6
        ldi R6, low(323)                                        ; Установить R6 как 67
        ldi R7, double(double(double(2)))                       ; Установить R7 как 16
        ldi R8, (~2- ~2 + ~2 - ~2) || 1                         ; Установить R8 как 1
        ldi R9, 1 && (1 || 0 || 0 || 1) ? double(3) : ~3 << 1   ; Установить R9 как 6

output: out R1                          ;
        out R2                          ; Тупой вывод всех результатов
        out R3                          ;
        out R4                          
        out R5                          ; Подобные выражения - ни как не влияют на сам язык
        out R6                          ; Если они не зависят от переменных (регистров), 
        out R7                          ; они просчитываются при компиляции. Если зависят, то компилятор
        out R8                          ; считает независимые части, а остальное вставляет в виде
        out R9                          ; инструкций в код. Сам парсинг выражений - рекурсивное разделение
        out R9 / 2                      ; токенов в граф (см. исходники)
        out R9 << 2                     ;
        out R1+R2==R3?(R4+R5==R6?R7:R8):(-R9)    ; Их можно юзать и тут